package com.example.myapplication.datastructure;

import com.example.myapplication.model.FoodBank;

import java.util.ArrayList;
import java.util.List;

public class AVLTree {
    private FoodBank value;
    private AVLTree leftNode;
    private AVLTree rightNode;
    private int height;

    public AVLTree() {
        this.value = null;
        this.height = 0;
    }

    public AVLTree(FoodBank value) {
        if (value == null) {
            throw new IllegalArgumentException("FoodBank value must not be null when creating an AVLTree node.");
        }
        this.value = value;
        this.height = 1;
    }

    private int getHeight(AVLTree node) {
        if (node == null) {
            return 0;
        }
        return node.height;
    }

    private int getBalanceFactor(AVLTree node) {
        if (node == null) {
            return 0;
        }
        return getHeight(node.leftNode) - getHeight(node.rightNode);
    }

    private AVLTree rightRotate() {
        AVLTree x = this.leftNode;
        AVLTree T2 = x.rightNode;

        x.rightNode = this;
        this.leftNode = T2;

        this.height = Math.max(getHeight(this.leftNode), getHeight(this.rightNode)) + 1;
        x.height = Math.max(getHeight(x.leftNode), getHeight(x.rightNode)) + 1;

        return x;
    }

    private AVLTree leftRotate() {
        AVLTree y = this.rightNode;
        AVLTree T2 = y.leftNode;

        y.leftNode = this;
        this.rightNode = T2;

        this.height = Math.max(getHeight(this.leftNode), getHeight(this.rightNode)) + 1;
        y.height = Math.max(getHeight(y.leftNode), getHeight(y.rightNode)) + 1;

        return y;
    }

    private AVLTree minNodeValue(AVLTree node) {
        AVLTree current = node;
        while (current.leftNode != null) {
            current = current.leftNode;
        }
        return current;
    }

    public AVLTree insert(AVLTree node, FoodBank key) {
        if (key == null) {
            throw new IllegalArgumentException("Cannot insert a null FoodBank into AVLTree.");
        }
        if (node == null) {
            return new AVLTree(key);  // Ê≠£Âú®ÂàõÂª∫Êñ∞ËäÇÁÇπ
        }

        if (node.value == null) {
            node.value = key;  // ÂØπ‰∫éÂàùÂßãÁ©∫Ê†ëÊÉÖÂÜµÔºåÁõ¥Êé•ËÆæÁΩÆÂÄº
            node.height = 1;  // Êõ¥Êñ∞È´òÂ∫¶
            return node;
        }

        if (key.getCapacity() < node.value.getCapacity()) {
            node.leftNode = insert(node.leftNode, key);
        } else if (key.getCapacity() > node.value.getCapacity()) {
            node.rightNode = insert(node.rightNode, key);
        } else {
            return node; // ‰∏çÂÖÅËÆ∏ÂÆπÈáèÈáçÂ§ç
        }

        node.height = 1 + Math.max(getHeight(node.leftNode), getHeight(node.rightNode));
        return balanceTree(node, key);
    }

    private AVLTree balanceTree(AVLTree node, FoodBank key) {
        int balance = getBalanceFactor(node);

        // Left Left Case
        if (balance > 1 && key.getCapacity() < node.leftNode.value.getCapacity()) {
            return node.rightRotate();
        }

        // Right Right Case
        if (balance < -1 && key.getCapacity() > node.rightNode.value.getCapacity()) {
            return node.leftRotate();
        }

        // Left Right Case
        if (balance > 1 && key.getCapacity() > node.leftNode.value.getCapacity()) {
            node.leftNode = node.leftNode.leftRotate();
            return node.rightRotate();
        }

        // Right Left Case
        if (balance < -1 && key.getCapacity() < node.rightNode.value.getCapacity()) {
            node.rightNode = node.rightNode.rightRotate();
            return node.leftRotate();
        }

        return node;
    }


    private AVLTree performRotations(AVLTree node, FoodBank key, int balance) {
        if (balance > 1 && key.getCapacity() < (node.leftNode != null ? node.leftNode.value.getCapacity() : 0)) {
            return node.rightRotate();
        }
        if (balance < -1 && key.getCapacity() > (node.rightNode != null ? node.rightNode.value.getCapacity() : 0)) {
            return node.leftRotate();
        }
        if (balance > 1 && key.getCapacity() > (node.leftNode != null ? node.leftNode.value.getCapacity() : 0)) {
            node.leftNode = node.leftNode.leftRotate();
            return node.rightRotate();
        }
        if (balance < -1 && key.getCapacity() < (node.rightNode != null ? node.rightNode.value.getCapacity() : 0)) {
            node.rightNode = node.rightNode.rightRotate();
            return node.leftRotate();
        }
        return node;
    }



    public AVLTree deleteNode(AVLTree root, int capacity) {
        if (root == null) {
            return root;
        }

        if (capacity < root.value.getCapacity()) {
            root.leftNode = deleteNode(root.leftNode, capacity);
        } else if (capacity > root.value.getCapacity()) {
            root.rightNode = deleteNode(root.rightNode, capacity);
        } else {
            if ((root.leftNode == null) || (root.rightNode == null)) {
                AVLTree temp = root.leftNode != null ? root.leftNode : root.rightNode;

                if (temp == null) {
                    temp = root;
                    root = null;
                } else {
                    root = temp;
                }
            } else {
                AVLTree temp = minNodeValue(root.rightNode);
                root.value = temp.value;
                root.rightNode = deleteNode(root.rightNode, temp.value.getCapacity());
            }
        }

        if (root == null) {
            return root;
        }

        root.height = Math.max(getHeight(root.leftNode), getHeight(root.rightNode)) + 1;

        int balance = getBalanceFactor(root);

        // Balancing the tree
        if (balance > 1 && getBalanceFactor(root.leftNode) >= 0) {
            return root.rightRotate();
        }

        if (balance > 1 && getBalanceFactor(root.leftNode) < 0) {
            root.leftNode = root.leftNode.leftRotate();
            return root.rightRotate();
        }

        if (balance < -1 && getBalanceFactor(root.rightNode) <= 0) {
            return root.leftRotate();
        }

        if (balance < -1 && getBalanceFactor(root.rightNode) > 0) {
            root.rightNode = root.rightNode.rightRotate();
            return root.leftRotate();
        }

        return root;
    }
    public List<FoodBank> findAllGreaterThan(int capacity) {
        List<FoodBank> results = new ArrayList<>();
        findAllGreaterThan(this, capacity, results);
        return results;
    }

    private void findAllGreaterThan(AVLTree node, int capacity, List<FoodBank> results) {
        if (node != null && node.value != null) {
            if (node.value.getCapacity() > capacity) {
                results.add(node.value);
                findAllGreaterThan(node.rightNode, capacity, results);
            }
            findAllGreaterThan(node.leftNode, capacity, results);
        }
    }

    public List<FoodBank> findAllLessThan(int capacity) {
        List<FoodBank> results = new ArrayList<>();
        findAllLessThan(this, capacity, results);
        return results;
    }

    private void findAllLessThan(AVLTree node, int capacity, List<FoodBank> results) {
        if (node != null && node.value != null) {
            if (node.value.getCapacity() < capacity) {
                results.add(node.value);
                findAllLessThan(node.leftNode, capacity, results);
            }
            findAllLessThan(node.rightNode, capacity, results);
        }
    }

    public List<FoodBank> findAllEqualTo(int capacity) {
        List<FoodBank> results = new ArrayList<>();
        findAllEqualTo(this, capacity, results);
        return results;
    }

    private void findAllEqualTo(AVLTree node, int capacity, List<FoodBank> results) {
        if (node != null && node.value != null) {
            if (node.value.getCapacity() == capacity) {
                results.add(node.value);
            }
            findAllEqualTo(node.leftNode, capacity, results);
            findAllEqualTo(node.rightNode, capacity, results);
        }
    }
    public void printInOrder() {
        printInOrder(this);
    }

    private void printInOrder(AVLTree node) {
        if (node != null) {
            printInOrder(node.leftNode);
            if (node.value != null) {
                System.out.println("üêçüêçüêçüêçNode Capacity: " + node.value.getCapacity());
            }
            printInOrder(node.rightNode);
        }
    }
}
